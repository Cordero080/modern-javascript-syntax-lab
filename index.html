<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Modern JavaScript Syntax Lab</title>
    <link rel="stylesheet" href="./main.css" />
  </head>
  <body>
    <!-- Enhanced Holographic Cursor System -->
    <div class="cursor" id="cursor"></div>
    <div class="gravity-field" id="gravity-field"></div>
    <div class="wormhole" id="wormhole"></div>
    <div class="dimensional-rift" id="dimensional-rift"></div>

    <!-- VINE-INSPIRED QUANTUM NAVIGATION -->
    <nav class="quantum-nav" id="quantum-nav">
      <div class="nav-logo">
        <span class="logo-text" data-text="JS_LAB_V2.0">JS_LAB_V2.0</span>
        <div class="logo-particles"></div>
      </div>
      <div class="nav-links">
        <a href="#reality" class="nav-link" data-dimension="0">// INIT</a>
        <a href="#probability" class="nav-link" data-dimension="1">// EXEC</a>
        <a href="#entanglement" class="nav-link" data-dimension="2">// DEBUG</a>
        <a href="#superposition" class="nav-link" data-dimension="3"
          >// DEPLOY</a
        >
        <div class="nav-terminal">
          <span class="terminal-cursor">[ACTIVE]</span>
        </div>
      </div>
      <div class="nav-quantum-field"></div>
    </nav>

    <!-- Parallax Container -->
    <div class="parallax-container" id="parallax-container">
      <!-- Scene 1: Reality Layer -->
      <section class="quantum-scene" id="reality" data-scene="0">
        <div class="scene-background bg-reality"></div>
        <div class="scene-content">
          <div class="particles">
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
          </div>
          <div class="terminal-header">
            <span class="coordinates">37.7749° N, 122.4194° W</span>
            <span class="timestamp" id="timestamp"></span>
          </div>

          <h1 class="quantum-title" data-text="MODERN JAVASCRIPT SYNTAX LAB">
            <span class="title-word" data-word="0">MODERN</span>
            <span class="title-word" data-word="1">JAVASCRIPT</span>
            <span class="title-word" data-word="2">SYNTAX</span>
            <span class="title-word" data-word="3">LAB</span>
          </h1>

          <p class="quantum-subtitle">
            / / I N T E R A C T I V E _ C O N S O L E _ A W A I T S . . .
          </p>

          <div class="hero-stats">
            <div class="stat-item">
              <span class="stat-label">MODULES LOADED</span>
              <span class="stat-value" data-stat="modules">003</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">QUANTUM STATE</span>
              <span class="stat-value" data-stat="state">STABLE</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">NETWORK STATUS</span>
              <span class="stat-value" data-stat="network">CONNECTED</span>
            </div>
          </div>
          <div class="reality-particles"></div>
        </div>
      </section>

      <!-- Scene 2: Probability Wave -->
      <section class="quantum-scene" id="probability" data-scene="1">
        <div class="scene-background bg-probability"></div>
        <div class="scene-content">
          <h2 class="scene-title">PROBABILITY CLOUD</h2>
          <p class="scene-description">
            Where code exists in superposition until observed
          </p>
          <div class="probability-waves"></div>
          <div class="code-snippets">
            <div class="floating-code">
              import name from './exportingFile.js';
            </div>
            <div class="floating-code">console.future(identity);</div>
            <div class="floating-code">PABLO DANIEL CORDERO</div>
          </div>
        </div>
      </section>

      <!-- Scene 3: Quantum Entanglement -->
      <section class="quantum-scene" id="entanglement" data-scene="2">
        <div class="scene-background bg-entanglement"></div>
        <div class="scene-content">
          <h2 class="scene-title">QUANTUM ENTANGLEMENT</h2>
          <p class="scene-description">
            Modules connected across infinite space
          </p>
          <div class="entanglement-network"></div>
          <div class="connected-nodes">
            <div class="node" data-module="export">NO</div>
            <div class="node" data-module="import">TRY</div>
            <div class="quantum-bridge"></div>
          </div>
        </div>
      </section>

      <!-- Scene 4: Superposition -->
      <section class="quantum-scene" id="superposition" data-scene="3">
        <div class="scene-background bg-superposition"></div>
        <div class="scene-content">
          <h2 class="scene-title">SUPERPOSITION STATE</h2>
          <p class="scene-description">
            All possibilities exist simultaneously
          </p>
          <div class="superposition-field"></div>
          <div class="quantum-console">
            <div class="console-line">>>> Initializing quantum state...</div>
            <div class="console-line">>>> PABLO PISTOLA = ψ(quantum_state)</div>
            <div class="console-line">
              >>> Observation collapsed wave function
            </div>
            <div class="console-line">>>> Result: "ETHEREAL" ✨</div>
          </div>
        </div>
      </section>
    </div>

    <!-- Quantum Scroll Progress -->
    <div class="quantum-progress">
      <div class="progress-bar"></div>
      <div class="progress-particles"></div>
    </div>

    <!-- QUANTUM CONSTELLATION CURSOR UNIVERSE -->
    <script>
      // QUANTUM CONSTELLATION CURSOR UNIVERSE ENGINE
      class QuantumCursorUniverse {
        constructor() {
          this.cursor = document.getElementById("cursor");
          this.gravityField = document.getElementById("gravity-field");
          this.wormhole = document.getElementById("wormhole");
          this.dimensionalRift = document.getElementById("dimensional-rift");

          this.mouseX = 0;
          this.mouseY = 0;
          this.targetX = 0;
          this.targetY = 0;

          this.particles = [];
          this.energyWaves = [];
          this.maxParticles = 50;
          this.maxEnergyWaves = 6; // Hexagon formation

          this.isMouseMoving = false;
          this.moveTimeout = null;
          this.quantumState = 0;
          this.wormholeActive = false;
          this.dimensionalTear = false;

          this.init();
        }

        init() {
          // Hide default cursor
          document.body.style.cursor = "none";

          this.createParticleSystem();
          this.createEnergyWaves();

          document.addEventListener("mousemove", (e) =>
            this.updateMousePosition(e)
          );
          document.addEventListener("click", () => this.createWormhole());
          document.addEventListener("mousedown", () =>
            this.createDimensionalRift()
          );
          document.addEventListener("mouseup", () =>
            this.closeDimensionalRift()
          );

          this.animate();
        }

        updateMousePosition(e) {
          this.mouseX = e.clientX;
          this.mouseY = e.clientY;

          this.isMouseMoving = true;
          this.cursor.style.opacity = "1";

          clearTimeout(this.moveTimeout);
          this.moveTimeout = setTimeout(() => {
            this.isMouseMoving = false;
          }, 100);

          this.createQuantumParticles();
        }

        createParticleSystem() {
          for (let i = 0; i < this.maxParticles; i++) {
            const particle = document.createElement("div");
            particle.className = "quantum-particle";
            document.body.appendChild(particle);

            this.particles.push({
              element: particle,
              x: Math.random() * window.innerWidth,
              y: Math.random() * window.innerHeight,
              vx: (Math.random() - 0.5) * 1.5,
              vy: (Math.random() - 0.5) * 1.5,
              life: Math.random(),
              maxLife: Math.random() * 4 + 2,
              hue: Math.random() * 360,
              baseSize: 0.8 + Math.random() * 0.4,
            });
          }
        }

        createEnergyWaves() {
          // Create perfect hexagonal symmetry
          for (let i = 0; i < this.maxEnergyWaves; i++) {
            const wave = document.createElement("div");
            wave.className = "energy-wave";
            document.body.appendChild(wave);

            this.energyWaves.push({
              element: wave,
              angle: (360 / this.maxEnergyWaves) * i, // Perfect 60-degree spacing for hexagon
              distance: 50,
              speed: Math.random() * 1.5 + 0.8,
            });
          }
        }

        createQuantumParticles() {
          const particle =
            this.particles[Math.floor(Math.random() * this.particles.length)];
          if (particle) {
            particle.x = this.mouseX + (Math.random() - 0.5) * 100;
            particle.y = this.mouseY + (Math.random() - 0.5) * 100;
            particle.vx = (Math.random() - 0.5) * 8;
            particle.vy = (Math.random() - 0.5) * 8;
            particle.life = particle.maxLife;
            particle.hue = Math.random() * 360;
          }
        }

        createWormhole() {
          this.wormholeActive = true;
          this.wormhole.style.opacity = "1";
          this.wormhole.style.left = this.mouseX - 75 + "px";
          this.wormhole.style.top = this.mouseY - 75 + "px";

          // Trigger ripple animation
          this.wormhole.classList.remove("ripple");
          // Force reflow to restart animation
          void this.wormhole.offsetWidth;
          this.wormhole.classList.add("ripple");

          // Suck in nearby particles
          this.particles.forEach((particle) => {
            const dx = this.mouseX - particle.x;
            const dy = this.mouseY - particle.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < 150) {
              particle.vx += dx * 0.1;
              particle.vy += dy * 0.1;
            }
          });

          setTimeout(() => {
            this.wormholeActive = false;
            this.wormhole.style.opacity = "0";
            this.wormhole.classList.remove("ripple");
          }, 700);
        }

        createDimensionalRift() {
          this.dimensionalTear = true;
          this.dimensionalRift.style.opacity = "1";
          this.dimensionalRift.style.left = this.mouseX - 150 + "px";
          this.dimensionalRift.style.top = this.mouseY + "px";
          this.dimensionalRift.style.transform = `rotate(${
            Math.random() * 360
          }deg)`;
        }

        closeDimensionalRift() {
          this.dimensionalTear = false;
          this.dimensionalRift.style.opacity = "0";
        }

        updatePhysics() {
          // Ultra smooth cursor following with refined easing
          this.targetX += (this.mouseX - this.targetX) * 0.15;
          this.targetY += (this.mouseY - this.targetY) * 0.15;

          this.cursor.style.left = this.targetX - 10 + "px";
          this.cursor.style.top = this.targetY - 10 + "px";

          // Smooth gravity field positioning
          this.gravityField.style.left = this.mouseX - 90 + "px";
          this.gravityField.style.top = this.mouseY - 90 + "px";

          // Enhanced quantum particle physics
          this.particles.forEach((particle) => {
            // More refined gravity calculation
            const dx = this.mouseX - particle.x;
            const dy = this.mouseY - particle.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > 0 && distance < 200) {
              const force = Math.min(30 / (distance * 0.5), 0.3);
              particle.vx += (dx / distance) * force * 0.08;
              particle.vy += (dy / distance) * force * 0.08;
            }

            // Enhanced velocity and movement
            particle.x += particle.vx;
            particle.y += particle.vy;

            // Refined friction for smoother movement
            particle.vx *= 0.985;
            particle.vy *= 0.985;

            // Smooth boundary wrapping
            if (particle.x < -10) particle.x = window.innerWidth + 10;
            if (particle.x > window.innerWidth + 10) particle.x = -10;
            if (particle.y < -10) particle.y = window.innerHeight + 10;
            if (particle.y > window.innerHeight + 10) particle.y = -10;

            // Enhanced life cycle with smoother transitions
            particle.life -= 0.008;
            if (particle.life <= 0) {
              particle.life = particle.maxLife;
              particle.x = Math.random() * window.innerWidth;
              particle.y = Math.random() * window.innerHeight;
              particle.vx = (Math.random() - 0.5) * 1;
              particle.vy = (Math.random() - 0.5) * 1;
            }

            // Ultra smooth visual updates with enhanced colors
            particle.element.style.left = particle.x + "px";
            particle.element.style.top = particle.y + "px";
            const hueShift = (particle.hue + this.quantumState * 50) % 360;
            particle.element.style.background = `
              radial-gradient(circle, 
                hsl(${hueShift}, 100%, 80%) 0%, 
                hsl(${(hueShift + 60) % 360}, 100%, 60%) 30%,
                hsl(${(hueShift + 120) % 360}, 80%, 50%) 60%,
                transparent 100%
              )
            `;
            const lifeOpacity = Math.min(particle.life / particle.maxLife, 1);
            particle.element.style.opacity = lifeOpacity * 0.9;
            particle.element.style.transform = `scale(${
              0.8 + lifeOpacity * 0.4
            })`;
          });

          // Enhanced energy wave rotation with smooth transitions
          this.energyWaves.forEach((wave, index) => {
            wave.angle += wave.speed * 0.8;
            const radians = (wave.angle * Math.PI) / 180;
            const dynamicDistance =
              wave.distance + Math.sin(this.quantumState + index) * 10;
            const waveX = this.mouseX + Math.cos(radians) * dynamicDistance;
            const waveY = this.mouseY + Math.sin(radians) * dynamicDistance;

            wave.element.style.left = waveX + "px";
            wave.element.style.top = waveY - 30 + "px";
            wave.element.style.transform = `rotate(${wave.angle}deg) scale(${
              0.8 + Math.sin(this.quantumState * 2) * 0.3
            })`;

            const waveOpacity = this.isMouseMoving ? 0.7 : 0.4;
            wave.element.style.opacity = waveOpacity;

            // Dynamic color shifting for the hexagon ring
            const hue = (index * 60 + this.quantumState * 30) % 360; // 60 degrees apart for hexagon
            wave.element.style.background = `rgba(0, 255, 255, 0.6)`;
            wave.element.style.borderColor = `hsl(${hue}, 100%, 70%)`;
            wave.element.style.boxShadow = `0 0 8px hsl(${hue}, 100%, 70%)`;
          });

          // Ultra refined quantum state evolution
          this.quantumState += 0.015;
        }

        animate() {
          this.updatePhysics();
          requestAnimationFrame(() => this.animate());
        }
      }

      // QUANTUM PARALLAX SYSTEM
      class QuantumParallaxEngine {
        constructor() {
          this.scenes = document.querySelectorAll(".quantum-scene");
          this.nav = document.getElementById("quantum-nav");
          this.progressBar = document.querySelector(".progress-bar");
          this.currentScene = 0;
          this.scrollProgress = 0;

          this.init();
        }

        init() {
          window.addEventListener("scroll", () => this.handleScroll());
          window.addEventListener("resize", () => this.handleResize());

          // Smooth scroll for nav links
          document.querySelectorAll(".nav-link").forEach((link) => {
            link.addEventListener("click", (e) => {
              e.preventDefault();
              const targetId = link.getAttribute("href").substring(1);
              const target = document.getElementById(targetId);
              if (target) {
                target.scrollIntoView({
                  behavior: "smooth",
                  block: "start",
                });
              }
            });
          });

          this.updateParallax();
        }

        handleScroll() {
          const scrollTop = window.pageYOffset;
          const docHeight =
            document.documentElement.scrollHeight - window.innerHeight;
          this.scrollProgress = scrollTop / docHeight;

          // Update progress bar
          if (this.progressBar) {
            this.progressBar.style.width = this.scrollProgress * 100 + "%";
          }

          // Update navigation transparency
          const navOpacity = Math.min(1, scrollTop / 100);
          if (this.nav) {
            this.nav.style.background = `rgba(0, 0, 0, ${
              0.2 + navOpacity * 0.3
            })`;
          }

          this.updateParallax();
          this.updateSceneTransitions();
        }

        updateParallax() {
          this.scenes.forEach((scene, index) => {
            const rect = scene.getBoundingClientRect();
            const sceneProgress = 1 - rect.top / window.innerHeight;
            const isVisible = rect.top < window.innerHeight && rect.bottom > 0;

            if (isVisible) {
              // Quantum phase transitions
              const phase = Math.sin(sceneProgress * Math.PI);
              const quantumShift = sceneProgress * 50;

              // Apply quantum transformations
              const background = scene.querySelector(".scene-background");
              const content = scene.querySelector(".scene-content");

              if (background) {
                background.style.transform = `
                  translateY(${quantumShift * 0.5}px) 
                  scale(${1 + sceneProgress * 0.1})
                  rotate(${phase * 2}deg)
                `;
                background.style.filter = `
                  blur(${Math.abs(phase) * 2}px)
                  hue-rotate(${sceneProgress * 60}deg)
                  brightness(${0.8 + phase * 0.4})
                `;
              }

              if (content) {
                content.style.transform = `
                  translateY(${-quantumShift * 0.3}px)
                  translateZ(${phase * 100}px)
                `;
                content.style.opacity = Math.max(
                  0.3,
                  1 - Math.abs(sceneProgress - 0.5) * 2
                );
              }

              // Update current scene
              if (sceneProgress > 0.3 && sceneProgress < 0.7) {
                this.currentScene = index;
              }
            }
          });
        }

        updateSceneTransitions() {
          // Create quantum tunneling effects between scenes
          this.scenes.forEach((scene, index) => {
            const rect = scene.getBoundingClientRect();
            const centerY = rect.top + rect.height / 2;
            const distanceFromCenter = Math.abs(
              centerY - window.innerHeight / 2
            );
            const maxDistance = window.innerHeight;
            const tunnelEffect = 1 - distanceFromCenter / maxDistance;

            if (tunnelEffect > 0) {
              const quantumField =
                Math.sin(Date.now() * 0.001 + index) * tunnelEffect;
              scene.style.filter = `
                blur(${(1 - tunnelEffect) * 3}px)
                brightness(${0.7 + tunnelEffect * 0.5})
                saturate(${0.8 + quantumField * 0.4})
              `;
            }
          });
        }

        handleResize() {
          this.updateParallax();
        }
      }

      // Initialize both systems when page loads
      document.addEventListener("DOMContentLoaded", () => {
        new QuantumCursorUniverse();
        new QuantumParallaxEngine();

        // Initialize floating animations for title words
        document.querySelectorAll(".title-word").forEach((word, index) => {
          word.style.setProperty("--word-index", index);
        });
      });
    </script>

    <!-- Import your modules -->
    <script type="module" src="./importingFile.js"></script>

    <!-- Optionally include app.js exercises -->
    <script type="module" src="./app.js"></script>
  </body>
</html>
